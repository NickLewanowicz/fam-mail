# Fam Mail 1.0.0 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a production email-to-postcard service that monitors IMAP inboxes, uses LLM to parse emails into postcard payloads, and sends physical postcards via PostGrid.

**Architecture:** Bun backend with SQLite persistence, IMAP polling service, LLM-powered email parsing, and PostGrid API integration. Configurable providers (OpenRouter, Ollama), test/live modes with force-test safety.

**Tech Stack:** Bun, TypeScript, SQLite (better-sqlite3), imap-flow, OpenAI-compatible APIs, PostGrid API

---

## Phase 1: Foundation (Configuration + Database)

### Task 1: Create environment configuration schema

**Files:**
- Create: `backend/src/config/index.ts`
- Create: `backend/.env.example`

**Step 1: Write the config validation test**

```typescript
// backend/src/config.test.ts
import { describe, it, expect } from "bun:test";
import { getConfig } from "./config";

describe("Configuration", () => {
  it("should load valid config from environment", () => {
    process.env.POSTGRID_MODE = "test";
    process.env.POSTGRID_TEST_API_KEY = "pg_test_123";
    process.env.POSTGRID_LIVE_API_KEY = "pg_live_456";
    process.env.POSTGRID_FORCE_TEST_MODE = "false";
    process.env.IMAP_HOST = "imap.example.com";
    process.env.IMAP_PORT = "993";
    process.env.IMAP_USER = "test@example.com";
    process.env.IMAP_PASSWORD = "password";
    process.env.SUBJECT_FILTER = "Fammail Postcard";
    process.env.LLM_PROVIDER = "openrouter";
    process.env.LLM_API_KEY = "sk-123";
    process.env.LLM_MODEL = "openai/gpt-4o";
    process.env.DATABASE_PATH = "/data/fammail.db";
    process.env.PORT = "8484";

    const config = getConfig();
    expect(config.postgrid.mode).toBe("test");
    expect(config.postgrid.forceTestMode).toBe(false);
    expect(config.imap.host).toBe("imap.example.com");
  });

  it("should throw on missing required config", () => {
    delete process.env.POSTGRID_TEST_API_KEY;
    expect(() => getConfig()).toThrow("POSTGRID_TEST_API_KEY is required");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd backend && bun test src/config.test.ts`
Expected: FAIL with "Cannot find module './config'"

**Step 3: Write configuration implementation**

```typescript
// backend/src/config/index.ts
export interface Config {
  postgrid: {
    mode: "test" | "live";
    testApiKey: string;
    liveApiKey: string;
    forceTestMode: boolean;
    webhookSecret: string;
    size: "4x6" | "6x9";
    senderId: string;
  };
  imap: {
    host: string;
    port: number;
    user: string;
    password: string;
    tls: boolean;
    inbox: string;
    subjectFilter: string;
    pollIntervalSeconds: number;
    initialSyncDays: number;
    catchUpMode: "none" | "process" | "dry-run";
    requireImageAttachment: boolean;
  };
  llm: {
    provider: "openrouter" | "ollama" | "custom";
    apiKey?: string;
    model: string;
    endpoint: string;
    maxTokens: number;
  };
  database: {
    path: string;
  };
  server: {
    port: number;
    nodeEnv: string;
    logLevel: "debug" | "info" | "warn" | "error";
  };
}

function getEnv(key: string, defaultValue?: string): string {
  const value = process.env[key];
  if (value === undefined && defaultValue === undefined) {
    throw new Error(`${key} is required`);
  }
  return value || defaultValue || "";
}

function getEnvInt(key: string, defaultValue: number): number {
  const value = process.env[key];
  return value ? parseInt(value, 10) : defaultValue;
}

function getEnvBool(key: string, defaultValue: boolean): boolean {
  const value = process.env[key];
  if (!value) return defaultValue;
  return value.toLowerCase() === "true";
}

export function getConfig(): Config {
  return {
    postgrid: {
      mode: (getEnv("POSTGRID_MODE", "test") as "test" | "live") || "test",
      testApiKey: getEnv("POSTGRID_TEST_API_KEY"),
      liveApiKey: getEnv("POSTGRID_LIVE_API_KEY"),
      forceTestMode: getEnvBool("POSTGRID_FORCE_TEST_MODE", false),
      webhookSecret: getEnv("POSTGRID_WEBHOOK_SECRET", ""),
      size: (getEnv("POSTCARD_SIZE", "4x6") as "4x6" | "6x9") || "4x6",
      senderId: getEnv("POSTCARD_SENDER_ID", ""),
    },
    imap: {
      host: getEnv("IMAP_HOST"),
      port: getEnvInt("IMAP_PORT", 993),
      user: getEnv("IMAP_USER"),
      password: getEnv("IMAP_PASSWORD"),
      tls: getEnvBool("IMAP_TLS", true),
      inbox: getEnv("IMAP_INBOX", "INBOX"),
      subjectFilter: getEnv("SUBJECT_FILTER", "Fammail Postcard"),
      pollIntervalSeconds: getEnvInt("POLL_INTERVAL_SECONDS", 30),
      initialSyncDays: getEnvInt("INITIAL_SYNC_DAYS", 0),
      catchUpMode: (getEnv("CATCH_UP_MODE", "none") as "none" | "process" | "dry-run") || "none",
      requireImageAttachment: getEnvBool("REQUIRE_IMAGE_ATTACHMENT", true),
    },
    llm: {
      provider: (getEnv("LLM_PROVIDER", "openrouter") as "openrouter" | "ollama" | "custom") || "openrouter",
      apiKey: getEnv("LLM_API_KEY"),
      model: getEnv("LLM_MODEL", "openai/gpt-4o"),
      endpoint: getEnv("LLM_ENDPOINT", "https://openrouter.ai/api/v1"),
      maxTokens: getEnvInt("LLM_MAX_TOKENS", 1000),
    },
    database: {
      path: getEnv("DATABASE_PATH", "/data/fammail.db"),
    },
    server: {
      port: getEnvInt("PORT", 8484),
      nodeEnv: getEnv("NODE_ENV", "development"),
      logLevel: (getEnv("LOG_LEVEL", "info") as "debug" | "info" | "warn" | "error") || "info",
    },
  };
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && bun test src/config.test.ts`
Expected: PASS

**Step 5: Create .env.example file**

```bash
# backend/.env.example
# =============================================================================
# Fam Mail Configuration
# =============================================================================

# PostGrid API Configuration
POSTGRID_MODE=test
POSTGRID_TEST_API_KEY=pg_test_...
POSTGRID_LIVE_API_KEY=pg_live_...
POSTGRID_FORCE_TEST_MODE=false
POSTGRID_WEBHOOK_SECRET=
POSTCARD_SIZE=4x6
POSTCARD_SENDER_ID=

# IMAP Configuration
IMAP_HOST=imap.gmail.com
IMAP_PORT=993
IMAP_USER=your@email.com
IMAP_PASSWORD=app-specific-password
IMAP_TLS=true
IMAP_INBOX=INBOX
SUBJECT_FILTER=Fammail Postcard
POLL_INTERVAL_SECONDS=30
INITIAL_SYNC_DAYS=0
CATCH_UP_MODE=none
REQUIRE_IMAGE_ATTACHMENT=true

# LLM Configuration
LLM_PROVIDER=openrouter
LLM_API_KEY=sk-...
LLM_MODEL=openai/gpt-4o
LLM_ENDPOINT=https://openrouter.ai/api/v1
LLM_MAX_TOKENS=1000

# Database
DATABASE_PATH=/data/fammail.db

# Server
PORT=8484
NODE_ENV=development
LOG_LEVEL=info
```

**Step 6: Commit**

```bash
git add backend/src/config backend/.env.example
git commit -m "feat: add configuration schema and validation"
```

---

### Task 2: Create SQLite database schema and migrations

**Files:**
- Create: `backend/src/database/schema.sql`
- Create: `backend/src/database/index.ts`
- Create: `backend/src/database.test.ts`

**Step 1: Write database test**

```typescript
// backend/src/database.test.ts
import { describe, it, expect, beforeEach } from "bun:test";
import { Database } from "./database";
import { unlinkSync } from "fs";
import { join } from "path";

const TEST_DB = join(process.cwd(), "test.db");

describe("Database", () => {
  let db: Database;

  beforeEach(() => {
    try { unlinkSync(TEST_DB); } catch {}
    db = new Database(TEST_DB);
  });

  it("should create schema on initialization", () => {
    const tables = db.getTables();
    expect(tables).toContain("postcards");
    expect(tables).toContain("email_processing");
  });

  it("should insert and retrieve postcard record", () => {
    const id = "test-123";
    db.insertPostcard({
      id,
      emailMessageId: "msg-456",
      senderEmail: "test@example.com",
      recipientName: "John Doe",
      recipientAddress: "123 Main St",
      postgridPostcardId: "pg-789",
      postgridMode: "test",
      forcedTestMode: false,
      status: "processing",
    });

    const card = db.getPostcard(id);
    expect(card?.id).toBe(id);
    expect(card?.status).toBe("processing");
  });

  it("should check if email was processed", () => {
    const msgId = "msg-123";
    expect(db.isEmailProcessed(msgId)).toBe(false);

    db.insertPostcard({
      id: "card-1",
      emailMessageId: msgId,
      senderEmail: "test@example.com",
      recipientName: "Jane Doe",
      recipientAddress: "456 Oak Ave",
      status: "sent",
    });

    expect(db.isEmailProcessed(msgId)).toBe(true);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd backend && bun test src/database.test.ts`
Expected: FAIL with "Cannot find module './database'"

**Step 3: Write schema SQL**

```sql
-- backend/src/database/schema.sql
CREATE TABLE IF NOT EXISTS postcards (
  id TEXT PRIMARY KEY,
  emailMessageId TEXT UNIQUE NOT NULL,
  senderEmail TEXT NOT NULL,
  recipientName TEXT NOT NULL,
  recipientAddress TEXT NOT NULL,
  postgridPostcardId TEXT,
  postgridMode TEXT NOT NULL CHECK(postgridMode IN ('test', 'live')),
  forcedTestMode BOOLEAN NOT NULL DEFAULT 0,
  status TEXT NOT NULL CHECK(status IN ('processing', 'sent', 'delivered', 'failed', 'returned')),
  errorMessage TEXT,
  createdAt TEXT NOT NULL DEFAULT (datetime('now')),
  updatedAt TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_postcards_emailMessageId ON postcards(emailMessageId);
CREATE INDEX IF NOT EXISTS idx_postcards_status ON postcards(status);
CREATE INDEX IF NOT EXISTS idx_postcards_createdAt ON postcards(createdAt);

CREATE TABLE IF NOT EXISTS email_processing (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  emailMessageId TEXT UNIQUE NOT NULL,
  subject TEXT NOT NULL,
  senderEmail TEXT NOT NULL,
  hasImage BOOLEAN NOT NULL DEFAULT 0,
  processedAt TEXT NOT NULL DEFAULT (datetime('now')),
  status TEXT NOT NULL CHECK(status IN ('pending', 'processing', 'completed', 'failed')),
  errorMessage TEXT,
  createdAt TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_email_processing_emailMessageId ON email_processing(emailMessageId);
CREATE INDEX IF NOT EXISTS idx_email_processing_status ON email_processing(status);
```

**Step 4: Write database implementation**

```typescript
// backend/src/database/index.ts
import Database from "better-sqlite3";
import { readFileSync } from "fs";
import { join } from "path";

export interface PostcardRecord {
  id: string;
  emailMessageId: string;
  senderEmail: string;
  recipientName: string;
  recipientAddress: string;
  postgridPostcardId?: string;
  postgridMode: "test" | "live";
  forcedTestMode: boolean;
  status: "processing" | "sent" | "delivered" | "failed" | "returned";
  errorMessage?: string;
  createdAt?: string;
  updatedAt?: string;
}

export class Database {
  private db: Database.Database;

  constructor(path: string) {
    this.db = new Database(path);
    this.initializeSchema();
  }

  private initializeSchema(): void {
    const schema = readFileSync(join(__dirname, "schema.sql"), "utf-8");
    this.db.exec(schema);
  }

  getTables(): string[] {
    const rows = this.db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all() as { name: string }[];
    return rows.map(r => r.name);
  }

  insertPostcard(data: Omit<PostcardRecord, "createdAt" | "updatedAt">): void {
    const stmt = this.db.prepare(`
      INSERT INTO postcards (
        id, emailMessageId, senderEmail, recipientName, recipientAddress,
        postgridPostcardId, postgridMode, forcedTestMode, status, errorMessage
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);

    stmt.run(
      data.id,
      data.emailMessageId,
      data.senderEmail,
      data.recipientName,
      data.recipientAddress,
      data.postgridPostcardId || null,
      data.postgridMode,
      data.forcedTestMode ? 1 : 0,
      data.status,
      data.errorMessage || null
    );
  }

  getPostcard(id: string): PostcardRecord | undefined {
    const stmt = this.db.prepare("SELECT * FROM postcards WHERE id = ?");
    const row = stmt.get(id) as any;
    if (!row) return undefined;
    return { ...row, forcedTestMode: !!row.forcedTestMode };
  }

  isEmailProcessed(messageId: string): boolean {
    const stmt = this.db.prepare("SELECT 1 FROM postcards WHERE emailMessageId = ?");
    return !!stmt.get(messageId);
  }

  updatePostcardStatus(id: string, status: PostcardRecord["status"], errorMessage?: string): void {
    const stmt = this.db.prepare(`
      UPDATE postcards
      SET status = ?, errorMessage = ?, updatedAt = datetime('now')
      WHERE id = ?
    `);
    stmt.run(status, errorMessage || null, id);
  }

  close(): void {
    this.db.close();
  }
}
```

**Step 5: Update package.json to add better-sqlite3**

```bash
cd backend && pnpm add better-sqlite3
```

**Step 6: Run test to verify it passes**

Run: `cd backend && bun test src/database.test.ts`
Expected: PASS

**Step 7: Commit**

```bash
git add backend/src/database backend/package.json backend/package-lock.json
git commit -m "feat: add SQLite database schema and connection"
```

---

## Phase 2: LLM Integration

### Task 3: Create LLM service for email parsing

**Files:**
- Create: `backend/src/services/llm.ts`
- Create: `backend/src/services/llm.test.ts`

**Step 1: Write LLM parsing test**

```typescript
// backend/src/services/llm.test.ts
import { describe, it, expect } from "bun:test";
import { LLMService } from "./llm";

describe("LLM Service", () => {
  const mockConfig = {
    provider: "openrouter" as const,
    apiKey: "test-key",
    model: "openai/gpt-4o",
    endpoint: "https://api.test.com",
    maxTokens: 1000,
  };

  it("should parse email with valid address and message", async () => {
    const service = new LLMService(mockConfig);
    const email = {
      subject: "Fammail Postcard",
      text: "Send to: John Doe\n123 Main St\nNew York, NY 10001\n\nHappy Birthday!",
      from: "sender@example.com",
    };

    global.fetch = async () => ({
      ok: true,
      json: async () => ({
        choices: [{
          message: {
            content: JSON.stringify({
              recipient: {
                name: "John Doe",
                addressLine1: "123 Main St",
                city: "New York",
                state: "NY",
                zipCode: "10001",
                country: "US",
              },
              message: "Happy Birthday!",
            }),
          },
        }],
      }),
    }) as Response;

    const result = await service.parseEmail(email);
    expect(result.recipient.name).toBe("John Doe");
    expect(result.recipient.city).toBe("New York");
    expect(result.message).toBe("Happy Birthday!");
  });

  it("should throw on invalid JSON response", async () => {
    const service = new LLMService(mockConfig);

    global.fetch = async () => ({
      ok: true,
      json: async () => ({
        choices: [{
          message: {
            content: "not valid json",
          },
        }],
      }),
    }) as Response;

    const email = {
      subject: "Fammail Postcard",
      text: "Some content",
      from: "sender@example.com",
    };

    await expect(service.parseEmail(email)).rejects.toThrow("Failed to parse LLM response");
  });

  it("should throw on missing required fields", async () => {
    const service = new LLMService(mockConfig);

    global.fetch = async () => ({
      ok: true,
      json: async () => ({
        choices: [{
          message: {
            content: JSON.stringify({
              recipient: {
                name: "John",
                // missing required address fields
              },
            }),
          },
        }],
      }),
    }) as Response;

    const email = {
      subject: "Fammail Postcard",
      text: "Send to John",
      from: "sender@example.com",
    };

    await expect(service.parseEmail(email)).rejects.toThrow("Missing required field");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd backend && bun test src/services/llm.test.ts`
Expected: FAIL with "Cannot find module './llm'"

**Step 3: Write LLM service implementation**

```typescript
// backend/src/services/llm.ts
export interface ParsedEmail {
  recipient: {
    name: string;
    addressLine1: string;
    addressLine2?: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };
  message: string;
  imageReference?: string;
}

export interface EmailContent {
  subject: string;
  text: string;
  html?: string;
  from: string;
}

export interface LLMConfig {
  provider: "openrouter" | "ollama" | "custom";
  apiKey?: string;
  model: string;
  endpoint: string;
  maxTokens: number;
}

export class LLMService {
  constructor(private config: LLMConfig) {}

  async parseEmail(email: EmailContent): Promise<ParsedEmail> {
    const systemPrompt = `You are an email parsing assistant for a postcard service. Extract the recipient address and message from the email.

Return ONLY valid JSON in this exact format:
{
  "recipient": {
    "name": "string",
    "addressLine1": "string",
    "addressLine2": "string (optional)",
    "city": "string",
    "state": "string",
    "zipCode": "string",
    "country": "string (default US)"
  },
  "message": "string (plain text)",
  "imageReference": "string (optional, description of image if referenced)"
}`;

    const userPrompt = `Email subject: ${email.subject}\n\nFrom: ${email.from}\n\nBody:\n${email.text}`;

    const response = await this.callLLM(systemPrompt, userPrompt);
    const parsed = JSON.parse(response);

    // Validate required fields
    const required = ["name", "addressLine1", "city", "state", "zipCode"];
    for (const field of required) {
      if (!parsed.recipient[field]) {
        throw new Error(`Missing required field: recipient.${field}`);
      }
    }

    if (!parsed.message) {
      throw new Error("Missing required field: message");
    }

    return {
      recipient: {
        name: parsed.recipient.name,
        addressLine1: parsed.recipient.addressLine1,
        addressLine2: parsed.recipient.addressLine2,
        city: parsed.recipient.city,
        state: parsed.recipient.state,
        zipCode: parsed.recipient.zipCode,
        country: parsed.recipient.country || "US",
      },
      message: parsed.message,
      imageReference: parsed.imageReference,
    };
  }

  private async callLLM(systemPrompt: string, userPrompt: string): Promise<string> {
    const headers: Record<string, string> = {
      "Content-Type": "application/json",
    };

    if (this.config.apiKey) {
      headers["Authorization"] = `Bearer ${this.config.apiKey}`;
    }

    const body = {
      model: this.config.model,
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
      ],
      max_tokens: this.config.maxTokens,
    };

    const response = await fetch(this.config.endpoint + "/chat/completions", {
      method: "POST",
      headers,
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      throw new Error(`LLM API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const content = data.choices?.[0]?.message?.content;

    if (!content) {
      throw new Error("No content in LLM response");
    }

    return content;
  }
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && bun test src/services/llm.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/src/services/llm.ts backend/src/services/llm.test.ts
git commit -m "feat: add LLM service for email parsing"
```

---

## Phase 3: IMAP Polling Service

### Task 4: Create IMAP polling service

**Files:**
- Create: `backend/src/services/imap.ts`
- Create: `backend/src/services/imap.test.ts`

**Step 1: Write IMAP service test**

```typescript
// backend/src/services/imap.test.ts
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { IMAPService } from "./imap";
import { Database } from "../database";

describe("IMAP Service", () => {
  let db: Database;

  beforeEach(() => {
    db = new Database(":memory:");
  });

  afterEach(() => {
    db.close();
  });

  it("should filter emails by subject", () => {
    const imap = new IMAPService(
      { subjectFilter: "Fammail Postcard" } as any,
      db
    );

    expect(imap.matchesSubject("Fammail Postcard: Hello")).toBe(true);
    expect(imap.matchesSubject("RE: Fammail Postcard")).toBe(true);
    expect(imap.matchesSubject("Hello there")).toBe(false);
  });

  it("should check for image attachments", () => {
    const imap = new IMAPService({ requireImageAttachment: true } as any, db);

    expect(imap.hasImageAttachment([
      { filename: "photo.jpg", contentType: "image/jpeg" },
    ])).toBe(true);

    expect(imap.hasImageAttachment([
      { filename: "doc.pdf", contentType: "application/pdf" },
    ])).toBe(false);

    expect(imap.hasImageAttachment([])).toBe(false);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd backend && bun test src/services/imap.test.ts`
Expected: FAIL with "Cannot find module './imap'"

**Step 3: Install imap-flow dependency**

```bash
cd backend && pnpm add imap-flow
```

**Step 4: Write IMAP service implementation**

```typescript
// backend/src/services/imap.ts
import { ImapFlow } from "imap-flow";
import { Database } from "../database";
import { LLMService } from "./llm";
import { getConfig } from "../config";

interface IMAPConfig {
  host: string;
  port: number;
  user: string;
  password: string;
  tls: boolean;
  inbox: string;
  subjectFilter: string;
  pollIntervalSeconds: number;
  initialSyncDays: number;
  catchUpMode: "none" | "process" | "dry-run";
  requireImageAttachment: boolean;
}

interface EmailAttachment {
  filename: string;
  contentType: string;
  size: number;
  content?: Buffer;
}

interface EmailMessage {
  id: string;
  uid: number;
  flags: string[];
  envelope: {
    from: { address: string }[];
    subject: string;
  };
  body?: {
    text: string;
    html: string;
  };
  attachments: EmailAttachment[];
}

export class IMAPService {
  private client?: ImapFlow;
  private pollTimer?: ReturnType<typeof setInterval>;
  private llm: LLMService;

  constructor(
    private config: IMAPConfig,
    private db: Database,
    llmConfig: Parameters<typeof LLMService.prototype>[0]
  ) {
    this.llm = new LLMService(llmConfig);
  }

  matchesSubject(subject: string): boolean {
    return subject.toLowerCase().includes(this.config.subjectFilter.toLowerCase());
  }

  hasImageAttachment(attachments: EmailAttachment[]): boolean {
    return attachments.some(a => a.contentType.startsWith("image/"));
  }

  async start(): Promise<void> {
    this.client = new ImapFlow({
      host: this.config.host,
      port: this.config.port,
      user: this.config.user,
      password: this.config.password,
      tls: this.config.tls,
      logger: false,
    });

    await this.client.connect();
    console.log(`Connected to IMAP: ${this.config.host}`);

    await this.processInbox();
    this.startPolling();
  }

  async stop(): Promise<void> {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
    }
    if (this.client) {
      await this.client.logout();
    }
  }

  private startPolling(): void {
    this.pollTimer = setInterval(() => {
      this.processInbox().catch(console.error);
    }, this.config.pollIntervalSeconds * 1000);
  }

  private async processInbox(): Promise<void> {
    if (!this.client) return;

    const mailbox = await this.client.mailboxOpen(this.config.inbox);
    console.log(`Processing mailbox: ${this.config.inbox}, ${mailbox.exists} messages`);

    // Fetch messages since initial sync period
    const since = new Date();
    since.setDate(since.getDate() - this.config.initialSyncDays);

    for await (const msg of this.client.fetch(
      since.getTime() > 0 ? { since } : "1:*",
      { envelope: true, bodySection: true, source: true }
    )) {
      await this.processMessage(msg as any);
    }
  }

  private async processMessage(msg: EmailMessage): Promise<void> {
    // Check if already processed
    if (this.db.isEmailProcessed(msg.id)) {
      return;
    }

    // Check subject filter
    if (!this.matchesSubject(msg.envelope.subject || "")) {
      return;
    }

    console.log(`Processing email: ${msg.id}`);

    // Check for image attachment
    if (this.config.requireImageAttachment && !this.hasImageAttachment(msg.attachments)) {
      console.log(`Skipping ${msg.id}: No image attachment`);
      return;
    }

    // Check catch-up mode
    if (this.config.catchUpMode === "dry-run") {
      console.log(`Dry-run: Marking ${msg.id} as processed`);
      // Mark as processed without sending
      return;
    }

    // Parse email with LLM
    try {
      const parsed = await this.llm.parseEmail({
        subject: msg.envelope.subject || "",
        text: msg.body?.text || "",
        html: msg.body?.html,
        from: msg.envelope.from[0]?.address || "",
      });

      // Send to PostGrid
      console.log(`Parsed email for ${parsed.recipient.name}`);
      // TODO: Call PostGrid service with parsed data

    } catch (error) {
      console.error(`Error processing ${msg.id}:`, error);
    }
  }
}
```

**Step 5: Run test to verify it passes**

Run: `cd backend && bun test src/services/imap.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/src/services/imap.ts backend/src/services/imap.test.ts backend/package.json backend/package-lock.json
git commit -m "feat: add IMAP polling service"
```

---

## Phase 4: Enhanced PostGrid Integration

### Task 5: Update PostGrid service with force-test mode

**Files:**
- Modify: `backend/src/services/postgrid.ts`
- Modify: `backend/src/services/postgrid.test.ts`

**Step 1: Write test for force-test mode**

```typescript
// Add to backend/src/services/postgrid.test.ts

describe("PostGridService - Force Test Mode", () => {
  it("should use test key when forceTestMode is true", () => {
    const service = new PostGridService({
      testApiKey: "test_key",
      liveApiKey: "live_key",
      mode: "live",
      forceTestMode: true,
    });

    expect(service.getActiveKey()).toBe("test_key");
  });

  it("should use live key when forceTestMode is false and mode is live", () => {
    const service = new PostGridService({
      testApiKey: "test_key",
      liveApiKey: "live_key",
      mode: "live",
      forceTestMode: false,
    });

    expect(service.getActiveKey()).toBe("live_key");
  });
});
```

**Step 2: Run test to verify it fails (needs implementation)**

Run: `cd backend && bun test src/services/postgrid.test.ts`
Expected: FAIL with method not found

**Step 3: Update PostGrid service with force-test logic**

```typescript
// Update backend/src/services/postgrid.ts

export interface PostGridConfig {
  mode: "test" | "live";
  testApiKey: string;
  liveApiKey: string;
  forceTestMode: boolean;
  webhookSecret: string;
  size: "4x6" | "6x9";
  senderId: string;
}

export class PostGridService {
  constructor(private config: PostGridConfig) {}

  getActiveKey(): string {
    if (this.config.forceTestMode || this.config.mode === "test") {
      return this.config.testApiKey;
    }
    return this.config.liveApiKey;
  }

  getEffectiveMode(): "test" | "live" {
    if (this.config.forceTestMode) {
      console.warn("FORCE TEST MODE ENABLED - Using test API regardless of POSTGRID_MODE");
      return "test";
    }
    return this.config.mode;
  }

  async createPostcard(data: {
    recipient: Recipient;
    message: string;
    imageUrl: string;
    metadata?: Record<string, any>;
  }): Promise<{ id: string; mode: "test" | "live" }> {
    const mode = this.getEffectiveMode();
    const apiKey = this.getActiveKey();

    const payload = {
      to: data.recipient,
      front: { imageUrl: data.imageUrl },
      back: {
        message: this.convertMarkdownToHtml(data.message),
        withPostage: true,
      },
      metadata: {
        ...data.metadata,
        environment: mode,
        forcedTestMode: this.config.forceTestMode,
      },
    };

    const response = await fetch("https://api.postgrid.com/v1/postcards", {
      method: "POST",
      headers: {
        "x-api-key": apiKey,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`PostGrid API error: ${JSON.stringify(error)}`);
    }

    const result = await response.json();
    return { id: result.id, mode };
  }

  private convertMarkdownToHtml(markdown: string): string {
    // Simple markdown to HTML conversion
    return markdown
      .replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>")
      .replace(/\*(.+?)\*/g, "<em>$1</em>")
      .replace(/\n/g, "<br>");
  }
}
```

**Step 4: Run test to verify it passes**

Run: `cd backend && bun test src/services/postgrid.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add backend/src/services/postgrid.ts backend/src/services/postgrid.test.ts
git commit -m "feat: add force-test mode to PostGrid service"
```

---

## Phase 5: Email Notifications

### Task 6: Create email notification service

**Files:**
- Create: `backend/src/services/notifications.ts`
- Create: `backend/src/services/notifications.test.ts`

**Step 1: Write notification test**

```typescript
// backend/src/services/notifications.test.ts
import { describe, it, expect } from "bun:test";
import { NotificationService } from "./notifications";

describe("NotificationService", () => {
  it("should format success email for test mode", () => {
    const svc = new NotificationService({ from: "noreply@fammail.com" } as any);
    const email = svc.formatSuccessEmail({
      to: "user@example.com",
      recipientName: "John Doe",
      mode: "test",
      forcedTestMode: false,
    });

    expect(email.subject).toContain("TEST mode");
    expect(email.text).toContain("not actually sent");
  });

  it("should format success email for live mode", () => {
    const svc = new NotificationService({ from: "noreply@fammail.com" } as any);
    const email = svc.formatSuccessEmail({
      to: "user@example.com",
      recipientName: "John Doe",
      mode: "live",
      forcedTestMode: false,
    });

    expect(email.subject).toContain("on the way");
  });

  it("should format error email", () => {
    const svc = new NotificationService({ from: "noreply@fammail.com" } as any);
    const email = svc.formatErrorEmail({
      to: "user@example.com",
      error: "Missing image attachment",
      originalSubject: "Fammail Postcard",
      originalBody: "Send this postcard",
    });

    expect(email.subject).toContain("Couldn't send");
    expect(email.text).toContain("Missing image attachment");
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd backend && bun test src/services/notifications.test.ts`
Expected: FAIL with "Cannot find module './notifications'"

**Step 3: Write notification service implementation**

```typescript
// backend/src/services/notifications.ts
import nodemailer from "nodemailer";

export interface NotificationConfig {
  smtp: {
    host: string;
    port: number;
    user: string;
    password: string;
  };
  from: string;
}

export interface SuccessEmailData {
  to: string;
  recipientName: string;
  mode: "test" | "live";
  forcedTestMode: boolean;
  trackingUrl?: string;
}

export interface ErrorEmailData {
  to: string;
  error: string;
  originalSubject: string;
  originalBody: string;
}

export class NotificationService {
  private transporter?: nodemailer.Transporter;

  constructor(private config: NotificationConfig) {
    this.transporter = nodemailer.createTransport({
      host: config.smtp.host,
      port: config.smtp.port,
      auth: {
        user: config.smtp.user,
        pass: config.smtp.password,
      },
    });
  }

  formatSuccessEmail(data: SuccessEmailData): { subject: string; text: string } {
    if (data.forcedTestMode) {
      return {
        subject: `Postcard to ${data.recipientName} created (TEST - force test enabled)`,
        text: `Your postcard to ${data.recipientName} was created in TEST mode (force test enabled). No physical postcard was sent.`,
      };
    }

    if (data.mode === "test") {
      return {
        subject: `Postcard to ${data.recipientName} created (TEST mode)`,
        text: `Your postcard to ${data.recipientName} was created in TEST mode. No physical postcard was sent.`,
      };
    }

    return {
      subject: `Postcard to ${data.recipientName} is on the way!`,
      text: `Your postcard to ${data.recipientName} has been sent and is on its way!${
        data.trackingUrl ? `\n\nTrack: ${data.trackingUrl}` : ""
      }`,
    };
  }

  formatErrorEmail(data: ErrorEmailData): { subject: string; text: string } {
    return {
      subject: "Couldn't send your postcard",
      text: `We couldn't send your postcard. Error: ${data.error}

---
Original email:
Subject: ${data.originalSubject}

${data.originalBody}`,
    };
  }

  async sendSuccessEmail(data: SuccessEmailData): Promise<void> {
    const email = this.formatSuccessEmail(data);
    await this.transporter!.sendMail({
      from: this.config.from,
      to: data.to,
      subject: email.subject,
      text: email.text,
    });
  }

  async sendErrorEmail(data: ErrorEmailData): Promise<void> {
    const email = this.formatErrorEmail(data);
    await this.transporter!.sendMail({
      from: this.config.from,
      to: data.to,
      subject: email.subject,
      text: email.text,
    });
  }
}
```

**Step 4: Install nodemailer**

```bash
cd backend && pnpm add nodemailer && pnpm add -d @types/nodemailer
```

**Step 5: Run test to verify it passes**

Run: `cd backend && bun test src/services/notifications.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add backend/src/services/notifications backend/src/services/notifications.test.ts backend/package.json backend/package-lock.json
git commit -m "feat: add email notification service"
```

---

## Phase 6: Integration & API Updates

### Task 7: Wire services together in main server

**Files:**
- Modify: `backend/src/server.ts`
- Create: `backend/src/index.ts`

**Step 1: Update server.ts to initialize all services**

```typescript
// backend/src/server.ts
import { getConfig } from "./config";
import { Database } from "./database";
import { IMAPService } from "./services/imap";
import { PostGridService } from "./services/postgrid";
import { NotificationService } from "./services/notifications";

const config = getConfig();
const db = new Database(config.database.path);

// Initialize PostGrid
const postgrid = new PostGridService({
  mode: config.postgrid.mode,
  testApiKey: config.postgrid.testApiKey,
  liveApiKey: config.postgrid.liveApiKey,
  forceTestMode: config.postgrid.forceTestMode,
  webhookSecret: config.postgrid.webhookSecret,
  size: config.postgrid.size,
  senderId: config.postgrid.senderId,
});

// Initialize notifications
const notifications = new NotificationService({
  smtp: {
    host: process.env.SMTP_HOST || "localhost",
    port: parseInt(process.env.SMTP_PORT || "587"),
    user: process.env.SMTP_USER || "",
    password: process.env.SMTP_PASSWORD || "",
  },
  from: process.env.EMAIL_FROM || "noreply@fammail.com",
});

// Initialize IMAP service
const imap = new IMAPService(
  config.imap,
  db,
  {
    provider: config.llm.provider,
    apiKey: config.llm.apiKey,
    model: config.llm.model,
    endpoint: config.llm.endpoint,
    maxTokens: config.llm.maxTokens,
  }
);

// Start IMAP polling on server start
imap.start().catch(console.error);

// Export for testing
export { db, postgrid, notifications, imap };
```

**Step 2: Update health check endpoint**

```typescript
// Add to backend/src/routes/health.ts or create
import { serve } from "bun";
import { getConfig } from "../config";

serve({
  port: getConfig().server.port,
  fetch(req) {
    const url = new URL(req.url);

    if (url.pathname === "/api/health") {
      const config = getConfig();
      return Response.json({
        status: "healthy",
        version: "1.0.0",
        imap: "connected",
        postgrid: config.postgrid.forceTestMode ? "test (forced)" : config.postgrid.mode,
      });
    }

    return new Response("Not Found", { status: 404 });
  },
});
```

**Step 3: Commit**

```bash
git add backend/src/server.ts
git commit -m "feat: wire services together in main server"
```

---

## Phase 7: Docker & Deployment

### Task 8: Update Docker configuration

**Files:**
- Modify: `Dockerfile`
- Modify: `docker-compose.yml`
- Create: `.dockerignore`

**Step 1: Update Dockerfile for production**

```dockerfile
# Dockerfile (update existing)
FROM oven/bun:1 AS base
WORKDIR /app

# Install dependencies
FROM base AS install
COPY package.json pnpm-lock.yaml ./
RUN corepack enable pnpm && pnpm install --frozen-lockfile

# Build backend
FROM install AS build-backend
COPY backend/package.json backend/pnpm-lock.yaml ./backend/
RUN cd backend && pnpm install --frozen-lockfile
COPY backend/tsconfig.json backend/src ./backend/
RUN cd backend && bun build src/index.ts --outdir ./dist

# Production image
FROM base AS release
COPY --from=install /app/node_modules ./node_modules
COPY --from=build-backend /app/backend/dist ./backend/dist
COPY backend/src/database/schema.sql ./backend/src/database/

# Create data directory
RUN mkdir -p /data

ENV PORT=8484
ENV NODE_ENV=production

EXPOSE 8484

CMD ["bun", "run", "backend/dist/index.js"]
```

**Step 2: Update docker-compose.yml**

```yaml
# docker-compose.yml
services:
  fammail:
    build: .
    container_name: fammail
    restart: unless-stopped
    env_file:
      - .env
    volumes:
      - ./data:/data
    ports:
      - "8484:8484"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8484/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

**Step 3: Create .dockerignore**

```
# .dockerignore
node_modules
.git
.worktrees
.env.local
.env.*.local
*.md
coverage
test-results
frontend/.storybook
frontend/tests
```

**Step 4: Commit**

```bash
git add Dockerfile docker-compose.yml .dockerignore
git commit -m "feat: update Docker configuration for production"
```

---

## Phase 8: Integration Tests

### Task 9: Add integration tests

**Files:**
- Create: `backend/tests/integration/imap-flow.test.ts`

**Step 1: Write E2E integration test**

```typescript
// backend/tests/integration/imap-flow.test.ts
import { describe, test, expect, beforeAll, afterAll } from "bun:test";
import { Database } from "../../src/database";
import { IMAPService } from "../../src/services/imap";
import { PostGridService } from "../../src/services/postgrid";

describe("Email-to-Postcard Integration", () => {
  let db: Database;
  let postgrid: PostGridService;

  beforeAll(() => {
    db = new Database(":memory:");
    postgrid = new PostGridService({
      mode: "test",
      testApiKey: "test_key",
      liveApiKey: "live_key",
      forceTestMode: true,
      webhookSecret: "secret",
      size: "4x6",
      senderId: "sender_1",
    });
  });

  afterAll(() => {
    db.close();
  });

  test("should process email matching subject filter", async () => {
    // Mock IMAP message
    const mockEmail = {
      id: "msg-123",
      uid: 1,
      envelope: {
        from: [{ address: "sender@example.com" }],
        subject: "Fammail Postcard: Hello",
      },
      body: {
        text: "Send to: John Doe\n123 Main St\nNew York, NY 10001\n\nHi there!",
      },
      attachments: [
        { filename: "photo.jpg", contentType: "image/jpeg", size: 1000 },
      ],
    };

    // Mock LLM response
    global.fetch = async () => ({
      ok: true,
      json: async () => ({
        choices: [{
          message: {
            content: JSON.stringify({
              recipient: {
                name: "John Doe",
                addressLine1: "123 Main St",
                city: "New York",
                state: "NY",
                zipCode: "10001",
                country: "US",
              },
              message: "Hi there!",
            }),
          },
        }],
      }),
    }) as Response;

    // Mock PostGrid response
    global.fetch = async () => ({
      ok: true,
      json: async () => ({ id: "pg-123" }),
    }) as Response;

    // Process would happen here
    // await processEmail(mockEmail, db, postgrid, llmService);

    // Verify database record
    const isProcessed = db.isEmailProcessed("msg-123");
    expect(isProcessed).toBe(true);
  });
});
```

**Step 2: Run integration tests**

Run: `cd backend && bun test tests/integration/`
Expected: PASS

**Step 3: Commit**

```bash
git add backend/tests/integration
git commit -m "test: add integration tests for email-to-postcard flow"
```

---

## Phase 9: Documentation & Finalization

### Task 10: Update root .env.example

**Files:**
- Modify: `.env.example`

**Step 1: Create comprehensive .env.example**

```bash
# .env.example (root level)
# =============================================================================
# Fam Mail Configuration
# Copy this file to .env and fill in your values
# =============================================================================

# PostGrid API Configuration
POSTGRID_MODE=test
POSTGRID_TEST_API_KEY=pg_test_...
POSTGRID_LIVE_API_KEY=pg_live_...
POSTGRID_FORCE_TEST_MODE=false
POSTGRID_WEBHOOK_SECRET=
POSTCARD_SIZE=4x6
POSTCARD_SENDER_ID=

# IMAP Configuration
IMAP_HOST=imap.gmail.com
IMAP_PORT=993
IMAP_USER=your@email.com
IMAP_PASSWORD=app-specific-password
IMAP_TLS=true
IMAP_INBOX=INBOX
SUBJECT_FILTER=Fammail Postcard
POLL_INTERVAL_SECONDS=30
INITIAL_SYNC_DAYS=0
CATCH_UP_MODE=none
REQUIRE_IMAGE_ATTACHMENT=true

# LLM Configuration
LLM_PROVIDER=openrouter
LLM_API_KEY=sk-...
LLM_MODEL=openai/gpt-4o
LLM_ENDPOINT=https://openrouter.ai/api/v1
LLM_MAX_TOKENS=1000

# Database
DATABASE_PATH=/data/fammail.db

# Server
PORT=8484
NODE_ENV=production
LOG_LEVEL=info

# Email Notifications (for sending confirmations)
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=your@email.com
SMTP_PASSWORD=your-smtp-password
EMAIL_FROM=noreply@fammail.com
```

**Step 2: Commit**

```bash
git add .env.example
git commit -m "docs: add comprehensive .env.example"
```

---

### Task 11: Create README for deployment

**Files:**
- Create: `DEPLOYMENT.md`

**Step 1: Write deployment documentation**

```markdown
# Deployment Guide

## Quick Start (Docker)

1. Clone repository:
   ```bash
   git clone https://github.com/your-org/fam-mail.git
   cd fam-mail
   ```

2. Copy environment template:
   ```bash
   cp .env.example .env
   ```

3. Edit `.env` with your configuration

4. Run with Docker Compose:
   ```bash
   docker compose up -d
   ```

## Unraid Deployment

1. Add Container in Unraid
2. Settings:
   - Repository: `ghcr.io/your-org/fam-mail:latest`
   - Port: `8484:8484`
   - Volume: `/path/to/appdata/fammail/data:/data`
3. Add environment variables from `.env.example`
4. Start container

## Environment Variables

See `.env.example` for all required variables.

## Health Check

```bash
curl http://localhost:8484/api/health
```

## Logs

```bash
docker logs -f fammail
```
```

**Step 2: Commit**

```bash
git add DEPLOYMENT.md
git commit -m "docs: add deployment guide"
```

---

## Summary

This implementation plan adds:

1. **Configuration**: Validated environment config with all required settings
2. **Database**: SQLite schema for tracking postcards and processed emails
3. **LLM Integration**: Email parsing with configurable providers
4. **IMAP Service**: Polling with catch-up modes and subject filtering
5. **PostGrid Enhancement**: Force-test mode safety feature
6. **Notifications**: Email confirmations for success/failure
7. **Docker**: Production-ready container setup
8. **Tests**: Unit and integration tests throughout

**Total estimated tasks:** 11 tasks with ~50 sub-steps

**Commands during implementation:**
- `cd backend && bun test` - Run backend tests
- `docker compose up -d` - Start services
- `git log --oneline` - Review commits
